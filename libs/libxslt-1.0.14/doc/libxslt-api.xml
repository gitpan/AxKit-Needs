<?xml version="1.0" encoding="ISO-8859-1"?>
<api name='libxslt'>
  <files>
    <file name='xsltutils'>
     <exports symbol='XSLT_TODO'/>
     <exports symbol='XSLT_STRANGE'/>
     <exports symbol='IS_XSLT_ELEM'/>
     <exports symbol='IS_XSLT_NAME'/>
     <exports symbol='IS_XSLT_REAL_NODE'/>
     <exports symbol='xsltGetNsProp'/>
     <exports symbol='xsltPrintErrorContext'/>
     <exports symbol='xsltMessage'/>
     <exports symbol='xsltSetGenericErrorFunc'/>
     <exports symbol='xsltSetGenericDebugFunc'/>
     <exports symbol='xsltDocumentSortFunction'/>
     <exports symbol='xsltDoSortFunction'/>
     <exports symbol='xsltGetQNameURI'/>
     <exports symbol='xsltSaveResultTo'/>
     <exports symbol='xsltSaveResultToFilename'/>
     <exports symbol='xsltSaveResultToFile'/>
     <exports symbol='xsltSaveResultToFd'/>
     <exports symbol='xsltSaveProfiling'/>
     <exports symbol='xsltTimestamp'/>
     <exports symbol='xsltCalibrateAdjust'/>
     <exports symbol='XSLT_TIMESTAMP_TICS_PER_SEC'/>
     <exports symbol='xsltDebugStatusCodes'/>
     <exports symbol='xsltHandleDebuggerCallback'/>
     <exports symbol='xsltAddCallCallback'/>
     <exports symbol='xsltDropCallCallback'/>
     <exports symbol='xsltSetDebuggerCallbacks'/>
     <exports symbol='xslAddCall'/>
     <exports symbol='xslDropCall'/>
    </file>
    <file name='xsltwin32config'>
     <exports symbol='LIBXSLT_DOTTED_VERSION'/>
     <exports symbol='LIBXSLT_VERSION'/>
     <exports symbol='LIBXSLT_VERSION_STRING'/>
     <exports symbol='WITH_XSLT_DEBUG'/>
     <exports symbol='DEBUG_MEMORY'/>
     <exports symbol='DEBUG_MEMORY_LOCATION'/>
     <exports symbol='ATTRIBUTE_UNUSED'/>
     <exports symbol='LIBXSLT_PUBLIC'/>
    </file>
    <file name='libxslt'>
     <exports symbol='IN_LIBXSLT'/>
     <exports symbol='LIBXSLT_PUBLIC'/>
    </file>
    <file name='numbersInternals'>
    </file>
    <file name='namespaces'>
     <exports symbol='xsltNamespaceAlias'/>
     <exports symbol='xsltGetNamespace'/>
     <exports symbol='xsltGetSpecialNamespace'/>
     <exports symbol='xsltCopyNamespace'/>
     <exports symbol='xsltCopyNamespaceList'/>
     <exports symbol='xsltFreeNamespaceAliasHashes'/>
    </file>
    <file name='extensions'>
     <exports symbol='xsltStyleExtInitFunction'/>
     <exports symbol='xsltStyleExtShutdownFunction'/>
     <exports symbol='xsltExtInitFunction'/>
     <exports symbol='xsltExtShutdownFunction'/>
     <exports symbol='xsltRegisterExtModule'/>
     <exports symbol='xsltRegisterExtModuleFull'/>
     <exports symbol='xsltUnregisterExtModule'/>
     <exports symbol='xsltGetExtData'/>
     <exports symbol='xsltStyleGetExtData'/>
     <exports symbol='xsltShutdownCtxtExts'/>
     <exports symbol='xsltShutdownExts'/>
     <exports symbol='xsltXPathGetTransformContext'/>
     <exports symbol='xsltRegisterExtModuleFunction'/>
     <exports symbol='xsltExtFunctionLookup'/>
     <exports symbol='xsltExtModuleFunctionLookup'/>
     <exports symbol='xsltUnregisterExtModuleFunction'/>
     <exports symbol='xsltNewElemPreComp'/>
     <exports symbol='xsltInitElemPreComp'/>
     <exports symbol='xsltRegisterExtModuleElement'/>
     <exports symbol='xsltExtElementLookup'/>
     <exports symbol='xsltExtModuleElementLookup'/>
     <exports symbol='xsltExtModuleElementPreComputeLookup'/>
     <exports symbol='xsltUnregisterExtModuleElement'/>
     <exports symbol='xsltTopLevelFunction'/>
     <exports symbol='xsltRegisterExtModuleTopLevel'/>
     <exports symbol='xsltExtModuleTopLevelLookup'/>
     <exports symbol='xsltUnregisterExtModuleTopLevel'/>
     <exports symbol='xsltRegisterExtFunction'/>
     <exports symbol='xsltRegisterExtElement'/>
     <exports symbol='xsltRegisterExtPrefix'/>
     <exports symbol='xsltCheckExtPrefix'/>
     <exports symbol='xsltInitCtxtExts'/>
     <exports symbol='xsltFreeCtxtExts'/>
     <exports symbol='xsltFreeExts'/>
     <exports symbol='xsltPreComputeExtModuleElement'/>
     <exports symbol='xsltRegisterTestModule'/>
    </file>
    <file name='attributes'>
     <exports symbol='xsltParseStylesheetAttributeSet'/>
     <exports symbol='xsltFreeAttributeSetsHashes'/>
     <exports symbol='xsltApplyAttributeSet'/>
    </file>
    <file name='xsltInternals'>
     <exports symbol='XSLT_MAX_SORT'/>
     <exports symbol='XSLT_PAT_NO_PRIORITY'/>
     <exports symbol='xsltRuntimeExtra'/>
     <exports symbol='xsltRuntimeExtraPtr'/>
     <exports symbol='XSLT_RUNTIME_EXTRA'/>
     <exports symbol='XSLT_RUNTIME_EXTRA_FREE'/>
     <exports symbol='xsltTemplate'/>
     <exports symbol='xsltTemplatePtr'/>
     <exports symbol='xsltDecimalFormat'/>
     <exports symbol='xsltDecimalFormatPtr'/>
     <exports symbol='xsltDocument'/>
     <exports symbol='xsltDocumentPtr'/>
     <exports symbol='xsltTransformContext'/>
     <exports symbol='xsltTransformContextPtr'/>
     <exports symbol='xsltElemPreComp'/>
     <exports symbol='xsltElemPreCompPtr'/>
     <exports symbol='xsltTransformFunction'/>
     <exports symbol='xsltStyleType'/>
     <exports symbol='xsltElemPreCompDeallocator'/>
     <exports symbol='xsltStylePreComp'/>
     <exports symbol='xsltStylePreCompPtr'/>
     <exports symbol='xsltStackElem'/>
     <exports symbol='xsltStackElemPtr'/>
     <exports symbol='xsltStylesheet'/>
     <exports symbol='xsltStylesheetPtr'/>
     <exports symbol='xsltOutputType'/>
     <exports symbol='xsltTransformState'/>
     <exports symbol='CHECK_STOPPED'/>
     <exports symbol='CHECK_STOPPEDE'/>
     <exports symbol='CHECK_STOPPED0'/>
     <exports symbol='xsltNewStylesheet'/>
     <exports symbol='xsltParseStylesheetFile'/>
     <exports symbol='xsltFreeStylesheet'/>
     <exports symbol='xsltIsBlank'/>
     <exports symbol='xsltFreeStackElemList'/>
     <exports symbol='xsltDecimalFormatGetByName'/>
     <exports symbol='xsltParseStylesheetProcess'/>
     <exports symbol='xsltParseStylesheetOutput'/>
     <exports symbol='xsltParseStylesheetDoc'/>
     <exports symbol='xsltLoadStylesheetPI'/>
     <exports symbol='xsltNumberFormat'/>
     <exports symbol='xsltFormatNumberConversion'/>
     <exports symbol='xsltParseTemplateContent'/>
     <exports symbol='xsltAllocateExtra'/>
     <exports symbol='xsltAllocateExtraCtxt'/>
    </file>
    <file name='pattern'>
     <exports symbol='xsltCompMatch'/>
     <exports symbol='xsltCompMatchPtr'/>
     <exports symbol='xsltCompilePattern'/>
     <exports symbol='xsltFreeCompMatchList'/>
     <exports symbol='xsltTestCompMatchList'/>
     <exports symbol='xsltAddTemplate'/>
     <exports symbol='xsltGetTemplate'/>
     <exports symbol='xsltFreeTemplateHashes'/>
     <exports symbol='xsltCleanupTemplates'/>
     <exports symbol='xsltMatchPattern'/>
    </file>
    <file name='documents'>
     <exports symbol='xsltNewDocument'/>
     <exports symbol='xsltLoadDocument'/>
     <exports symbol='xsltFindDocument'/>
     <exports symbol='xsltFreeDocuments'/>
     <exports symbol='xsltLoadStyleDocument'/>
     <exports symbol='xsltNewStyleDocument'/>
     <exports symbol='xsltFreeStyleDocuments'/>
    </file>
    <file name='variables'>
     <exports symbol='XSLT_REGISTER_VARIABLE_LOOKUP'/>
     <exports symbol='xsltEvalGlobalVariables'/>
     <exports symbol='xsltEvalUserParams'/>
     <exports symbol='xsltQuoteUserParams'/>
     <exports symbol='xsltEvalOneUserParam'/>
     <exports symbol='xsltQuoteOneUserParam'/>
     <exports symbol='xsltParseGlobalVariable'/>
     <exports symbol='xsltParseGlobalParam'/>
     <exports symbol='xsltParseStylesheetVariable'/>
     <exports symbol='xsltParseStylesheetParam'/>
     <exports symbol='xsltParseStylesheetCallerParam'/>
     <exports symbol='xsltAddStackElemList'/>
     <exports symbol='xsltFreeGlobalVariables'/>
     <exports symbol='xsltVariableLookup'/>
     <exports symbol='xsltXPathVariableLookup'/>
    </file>
    <file name='imports'>
     <exports symbol='XSLT_GET_IMPORT_PTR'/>
     <exports symbol='XSLT_GET_IMPORT_INT'/>
     <exports symbol='xsltParseStylesheetImport'/>
     <exports symbol='xsltParseStylesheetInclude'/>
     <exports symbol='xsltNextImport'/>
     <exports symbol='xsltNeedElemSpaceHandling'/>
     <exports symbol='xsltFindElemSpaceHandling'/>
     <exports symbol='xsltFindTemplate'/>
    </file>
    <file name='keys'>
     <exports symbol='xsltAddKey'/>
     <exports symbol='xsltGetKey'/>
     <exports symbol='xsltInitCtxtKeys'/>
     <exports symbol='xsltFreeKeys'/>
     <exports symbol='xsltFreeDocumentKeys'/>
    </file>
    <file name='extra'>
     <exports symbol='XSLT_LIBXSLT_NAMESPACE'/>
     <exports symbol='XSLT_SAXON_NAMESPACE'/>
     <exports symbol='XSLT_XT_NAMESPACE'/>
     <exports symbol='XSLT_XALAN_NAMESPACE'/>
     <exports symbol='XSLT_NORM_SAXON_NAMESPACE'/>
     <exports symbol='xsltFunctionNodeSet'/>
     <exports symbol='xsltDebug'/>
     <exports symbol='xsltRegisterExtras'/>
     <exports symbol='xsltRegisterAllExtras'/>
    </file>
    <file name='preproc'>
     <exports symbol='xsltExtMarker'/>
     <exports symbol='xsltDocumentComp'/>
     <exports symbol='xsltStylePreCompute'/>
     <exports symbol='xsltFreeStylePreComps'/>
    </file>
    <file name='transform'>
     <exports symbol='xsltSetXIncludeDefault'/>
     <exports symbol='xsltGetXIncludeDefault'/>
     <exports symbol='xsltNewTransformContext'/>
     <exports symbol='xsltFreeTransformContext'/>
     <exports symbol='xsltApplyStylesheetUser'/>
     <exports symbol='xsltApplyStripSpaces'/>
     <exports symbol='xsltExtElementLookup'/>
     <exports symbol='xsltApplyStylesheet'/>
     <exports symbol='xsltProfileStylesheet'/>
     <exports symbol='xsltRunStylesheet'/>
     <exports symbol='xsltApplyOneTemplate'/>
     <exports symbol='xsltDocumentElem'/>
     <exports symbol='xsltSort'/>
     <exports symbol='xsltCopy'/>
     <exports symbol='xsltText'/>
     <exports symbol='xsltElement'/>
     <exports symbol='xsltComment'/>
     <exports symbol='xsltAttribute'/>
     <exports symbol='xsltProcessingInstruction'/>
     <exports symbol='xsltCopyOf'/>
     <exports symbol='xsltValueOf'/>
     <exports symbol='xsltNumber'/>
     <exports symbol='xsltApplyImports'/>
     <exports symbol='xsltCallTemplate'/>
     <exports symbol='xsltApplyTemplates'/>
     <exports symbol='xsltChoose'/>
     <exports symbol='xsltIf'/>
     <exports symbol='xsltForEach'/>
     <exports symbol='xsltRegisterAllElement'/>
     <exports symbol='xslHandleDebugger'/>
    </file>
    <file name='xslt'>
     <exports symbol='XSLT_DEFAULT_VERSION'/>
     <exports symbol='XSLT_DEFAULT_VENDOR'/>
     <exports symbol='XSLT_DEFAULT_URL'/>
     <exports symbol='XSLT_NAMESPACE'/>
     <exports symbol='LIBXSLT_PUBLIC'/>
     <exports symbol='xsltCleanupGlobals'/>
    </file>
    <file name='xsltconfig'>
     <exports symbol='LIBXSLT_DOTTED_VERSION'/>
     <exports symbol='LIBXSLT_VERSION'/>
     <exports symbol='LIBXSLT_VERSION_STRING'/>
     <exports symbol='WITH_XSLT_DEBUG'/>
     <exports symbol='DEBUG_MEMORY'/>
     <exports symbol='DEBUG_MEMORY_LOCATION'/>
     <exports symbol='WITH_XSLT_DEBUGGER'/>
     <exports symbol='ATTRIBUTE_UNUSED'/>
     <exports symbol='LIBXSLT_PUBLIC'/>
    </file>
    <file name='functions'>
     <exports symbol='XSLT_REGISTER_FUNCTION_LOOKUP'/>
     <exports symbol='xsltXPathFunctionLookup'/>
     <exports symbol='xsltDocumentFunction'/>
     <exports symbol='xsltKeyFunction'/>
     <exports symbol='xsltUnparsedEntityURIFunction'/>
     <exports symbol='xsltFormatNumberFunction'/>
     <exports symbol='xsltGenerateIdFunction'/>
     <exports symbol='xsltSystemPropertyFunction'/>
     <exports symbol='xsltElementAvailableFunction'/>
     <exports symbol='xsltFunctionAvailableFunction'/>
     <exports symbol='xsltRegisterAllFunctions'/>
    </file>
    <file name='templates'>
     <exports symbol='xsltEvalXPathPredicate'/>
     <exports symbol='xsltEvalTemplateString'/>
     <exports symbol='xsltEvalAttrValueTemplate'/>
     <exports symbol='xsltEvalStaticAttrValueTemplate'/>
     <exports symbol='xsltEvalXPathString'/>
     <exports symbol='xsltTemplateProcess'/>
     <exports symbol='xsltAttrListTemplateProcess'/>
     <exports symbol='xsltAttrTemplateProcess'/>
     <exports symbol='xsltAttrTemplateValueProcess'/>
    </file>
  </files>
  <symbols>
    <macro name='ATTRIBUTE_UNUSED' file='xsltwin32config'>
      <info>This macro is used to flag unused function parameters to GCC, useless here</info>
    </macro>
    <macro name='CHECK_STOPPED' file='xsltInternals'>
      <info>Macro to check if the XSLT processing should be stopped. Will return from the function.</info>
    </macro>
    <macro name='CHECK_STOPPED0' file='xsltInternals'>
      <info>Macro to check if the XSLT processing should be stopped. Will return from the function with a 0 value.</info>
    </macro>
    <macro name='CHECK_STOPPEDE' file='xsltInternals'>
      <info>Macro to check if the XSLT processing should be stopped. Will goto the error: label.</info>
    </macro>
    <macro name='DEBUG_MEMORY' file='xsltwin32config'>
      <info>should be activated only when debugging libxslt. It replaces the allocator with a collect and debug shell to the libc allocator. Use configure --with-mem-debug to activate it on both library</info>
    </macro>
    <macro name='DEBUG_MEMORY_LOCATION' file='xsltwin32config'>
      <info>should be activated only when debugging libxslt. DEBUG_MEMORY_LOCATION should be activated only when libxml has been configured with --with-debug-mem too</info>
    </macro>
    <macro name='IN_LIBXSLT' file='libxslt'>
    </macro>
    <macro name='IS_XSLT_ELEM' file='xsltutils'>
      <info>Checks that the element pertains to XSLT namespace.</info>
    </macro>
    <macro name='IS_XSLT_NAME' file='xsltutils'>
      <info>Checks the value of an element in XSLT namespace.</info>
    </macro>
    <macro name='IS_XSLT_REAL_NODE' file='xsltutils'>
      <info>Check that a node is a &apos;real&apos; one: document, element, text or attribute.</info>
    </macro>
    <macro name='LIBXSLT_DOTTED_VERSION' file='xsltwin32config'>
      <info>the version string like &quot;1.2.3&quot;</info>
    </macro>
    <macro name='LIBXSLT_PUBLIC' file='xsltwin32config'>
      <info>This macro is needed on Win32 when using MSVC. It enables the client code to access exported variables. It should expand to nothing when compiling this library itself, but must expand to __declspec(dllimport) when a client includes the library header and that only if it links dynamically against this library.</info>
    </macro>
    <macro name='LIBXSLT_VERSION' file='xsltwin32config'>
      <info>the version number: 1.2.3 value is 1002003</info>
    </macro>
    <macro name='LIBXSLT_VERSION_STRING' file='xsltwin32config'>
      <info>the version number string, 1.2.3 value is &quot;1002003&quot;</info>
    </macro>
    <macro name='WITH_XSLT_DEBUG' file='xsltwin32config'>
      <info>Activate the compilation of the debug reporting. Speed penalty is insignifiant and being able to run xsltpoc -v is useful. On by default</info>
    </macro>
    <macro name='WITH_XSLT_DEBUGGER' file='xsltconfig'>
      <info>Activate the compilation of the debugger support. Speed penalty is insignifiant. On by default unless --without-debugger is passed to configure</info>
    </macro>
    <const name='XSLT_DEBUG_CONT' file='xsltutils'/>
    <const name='XSLT_DEBUG_INIT' file='xsltutils'/>
    <const name='XSLT_DEBUG_NEXT' file='xsltutils'/>
    <const name='XSLT_DEBUG_NONE' file='xsltutils'/>
    <const name='XSLT_DEBUG_QUIT' file='xsltutils'/>
    <const name='XSLT_DEBUG_RUN' file='xsltutils'/>
    <const name='XSLT_DEBUG_RUN_RESTART' file='xsltutils'/>
    <const name='XSLT_DEBUG_STEP' file='xsltutils'/>
    <const name='XSLT_DEBUG_STEPOUT' file='xsltutils'/>
    <const name='XSLT_DEBUG_STOP' file='xsltutils'/>
    <macro name='XSLT_DEFAULT_URL' file='xslt'>
      <info>The XSLT &quot;vendor&quot; URL for this processor.</info>
    </macro>
    <macro name='XSLT_DEFAULT_VENDOR' file='xslt'>
      <info>The XSLT &quot;vendor&quot; string for this processor.</info>
    </macro>
    <macro name='XSLT_DEFAULT_VERSION' file='xslt'>
      <info>The default version of XSLT supported.</info>
    </macro>
    <const name='XSLT_FUNC_APPLYIMPORTS' file='xsltInternals'/>
    <const name='XSLT_FUNC_APPLYTEMPLATES' file='xsltInternals'/>
    <const name='XSLT_FUNC_ATTRIBUTE' file='xsltInternals'/>
    <const name='XSLT_FUNC_CALLTEMPLATE' file='xsltInternals'/>
    <const name='XSLT_FUNC_CHOOSE' file='xsltInternals'/>
    <const name='XSLT_FUNC_COMMENT' file='xsltInternals'/>
    <const name='XSLT_FUNC_COPY' file='xsltInternals'/>
    <const name='XSLT_FUNC_COPYOF' file='xsltInternals'/>
    <const name='XSLT_FUNC_DOCUMENT' file='xsltInternals'/>
    <const name='XSLT_FUNC_ELEMENT' file='xsltInternals'/>
    <const name='XSLT_FUNC_EXTENSION' file='xsltInternals'/>
    <const name='XSLT_FUNC_FOREACH' file='xsltInternals'/>
    <const name='XSLT_FUNC_IF' file='xsltInternals'/>
    <const name='XSLT_FUNC_NUMBER' file='xsltInternals'/>
    <const name='XSLT_FUNC_PARAM' file='xsltInternals'/>
    <const name='XSLT_FUNC_PI' file='xsltInternals'/>
    <const name='XSLT_FUNC_SORT' file='xsltInternals'/>
    <const name='XSLT_FUNC_TEXT' file='xsltInternals'/>
    <const name='XSLT_FUNC_VALUEOF' file='xsltInternals'/>
    <const name='XSLT_FUNC_VARIABLE' file='xsltInternals'/>
    <const name='XSLT_FUNC_WHEN' file='xsltInternals'/>
    <const name='XSLT_FUNC_WITHPARAM' file='xsltInternals'/>
    <macro name='XSLT_GET_IMPORT_INT' file='imports'>
      <info>A macro to import intergers from the stylesheet cascading order.</info>
    </macro>
    <macro name='XSLT_GET_IMPORT_PTR' file='imports'>
      <info>A macro to import pointers from the stylesheet cascading order.</info>
    </macro>
    <macro name='XSLT_LIBXSLT_NAMESPACE' file='extra'>
      <info>This is the libxslt namespace for specific extensions.</info>
    </macro>
    <macro name='XSLT_MAX_SORT' file='xsltInternals'>
      <info>Max number of specified xsl:sort on an element.</info>
    </macro>
    <macro name='XSLT_NAMESPACE' file='xslt'>
      <info>The XSLT specification namespace.</info>
    </macro>
    <macro name='XSLT_NORM_SAXON_NAMESPACE' file='extra'>
      <info>This is Norm&apos;s namespace for SAXON extensions.</info>
    </macro>
    <const name='XSLT_OUTPUT_HTML' file='xsltInternals'/>
    <const name='XSLT_OUTPUT_TEXT' file='xsltInternals'/>
    <const name='XSLT_OUTPUT_XML' file='xsltInternals'/>
    <macro name='XSLT_PAT_NO_PRIORITY' file='xsltInternals'>
      <info>Specific value for pattern without priority expressed.</info>
    </macro>
    <macro name='XSLT_REGISTER_FUNCTION_LOOKUP' file='functions'>
      <info>Registering macro, not general purpose at all but used in different modules.</info>
    </macro>
    <macro name='XSLT_REGISTER_VARIABLE_LOOKUP' file='variables'>
      <info>Registering macro, not general purpose at all but used in different modules.</info>
    </macro>
    <macro name='XSLT_RUNTIME_EXTRA' file='xsltInternals'>
    </macro>
    <macro name='XSLT_RUNTIME_EXTRA_FREE' file='xsltInternals'>
    </macro>
    <macro name='XSLT_SAXON_NAMESPACE' file='extra'>
      <info>This is Michael Kay&apos;s Saxon processor namespace for extensions.</info>
    </macro>
    <const name='XSLT_STATE_ERROR' file='xsltInternals'/>
    <const name='XSLT_STATE_OK' file='xsltInternals'/>
    <const name='XSLT_STATE_STOPPED' file='xsltInternals'/>
    <macro name='XSLT_STRANGE' file='xsltutils'>
    </macro>
    <macro name='XSLT_TIMESTAMP_TICS_PER_SEC' file='xsltutils'>
    </macro>
    <macro name='XSLT_TODO' file='xsltutils'>
    </macro>
    <macro name='XSLT_XALAN_NAMESPACE' file='extra'>
      <info>This is the Apache project XALAN processor namespace for extensions.</info>
    </macro>
    <macro name='XSLT_XT_NAMESPACE' file='extra'>
      <info>This is James Clark&apos;s XT processor namespace for extensions.</info>
    </macro>
    <function name='xslAddCall' file='xsltutils'>
      <info>Add template &quot;call&quot; to call stack</info>
      <return type='int' info=': 1 on sucess 0 otherwise an error may be printed if WITH_XSLT_DEBUG_BREAKPOINTS is defined '/>
      <arg name='templ' type='xsltTemplatePtr' info='current template being applied '/>
      <arg name='source' type='xmlNodePtr' info='the source node being processed '/>
    </function>
    <function name='xslDropCall' file='xsltutils'>
      <info>Drop the topmost item off the call stack</info>
      <return type='void'/>
    </function>
    <function name='xslHandleDebugger' file='transform'>
      <info>If either cur or node are a breakpoint, or xslDebugStatus in state where debugging must occcur at this time then transfer control to the xslDebugBreak function</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='source node being executed '/>
      <arg name='node' type='xmlNodePtr' info='data node being processed '/>
      <arg name='templ' type='xsltTemplatePtr' info='temlate that applies to node '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the xslt transform context '/>
    </function>
    <functype name='xsltAddCallCallback' file='xsltutils'>
      <return type='int'/>
      <arg name='templ' type='xsltTemplatePtr'/>
      <arg name='source' type='xmlNodePtr'/>
    </functype>
    <function name='xsltAddKey' file='keys'>
      <info>add a key definition to a stylesheet</info>
      <return type='int' info='0 in case of success, and -1 in case of failure. '/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet '/>
      <arg name='name' type='const xmlChar *' info='the key name or NULL '/>
      <arg name='nameURI' type='const xmlChar *' info='the name URI or NULL '/>
      <arg name='match' type='const xmlChar *' info='the match value '/>
      <arg name='use' type='const xmlChar *' info='the use value '/>
      <arg name='inst' type='xmlNodePtr' info='the key instruction '/>
    </function>
    <function name='xsltAddStackElemList' file='variables'>
      <info>add the new element list at this level of the stack.</info>
      <return type='int' info='0 in case of success, -1 in case of failure. '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='xn XSLT transformation context '/>
      <arg name='elems' type='xsltStackElemPtr' info='a stack element list '/>
    </function>
    <function name='xsltAddTemplate' file='pattern'>
      <info>Register the XSLT pattern associated to cur</info>
      <return type='int' info='-1 in case of error, 0 otherwise '/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet '/>
      <arg name='cur' type='xsltTemplatePtr' info='an XSLT template '/>
      <arg name='mode' type='const xmlChar *' info='the mode name or NULL '/>
      <arg name='modeURI' type='const xmlChar *' info='the mode URI or NULL '/>
    </function>
    <function name='xsltAllocateExtra' file='xsltInternals'>
      <info>Allocate an extra runtime information slot statically while compiling the stylesheet and return its number</info>
      <return type='int' info='the number of the slot '/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet '/>
    </function>
    <function name='xsltAllocateExtraCtxt' file='xsltInternals'>
      <info>Allocate an extra runtime information slot at run-time and return its number This make sure there is a slot ready in the transformation context</info>
      <return type='int' info='the number of the slot '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context '/>
    </function>
    <function name='xsltApplyAttributeSet' file='attributes'>
      <info>Apply the xsl:use-attribute-sets</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT stylesheet '/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree. '/>
      <arg name='inst' type='xmlNodePtr' info='the xslt attribute node '/>
      <arg name='attributes' type='xmlChar *' info='the set list. '/>
    </function>
    <function name='xsltApplyImports' file='transform'>
      <info>Process the xslt apply-imports node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context '/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree. '/>
      <arg name='inst' type='xmlNodePtr' info='the xslt apply-imports node '/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information '/>
    </function>
    <function name='xsltApplyOneTemplate' file='transform'>
      <info>Process the apply-templates node on the source node, if params are passed they are pushed on the variable stack but not popped, it&apos;s left to the caller to handle them back (they may be reused).</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context '/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree. '/>
      <arg name='list' type='xmlNodePtr' info='the template replacement nodelist '/>
      <arg name='templ' type='xsltTemplatePtr' info='if is this a real template processing, the template processed '/>
      <arg name='params' type='xsltStackElemPtr' info='a set of parameters for the template or NULL '/>
    </function>
    <function name='xsltApplyStripSpaces' file='transform'>
      <info>Strip the unwanted ignorable spaces from the input tree</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context '/>
      <arg name='node' type='xmlNodePtr'/>
    </function>
    <function name='xsltApplyStylesheet' file='transform'>
      <info>Apply the stylesheet to the document NOTE: This may lead to a non-wellformed output XML wise !</info>
      <return type='xmlDocPtr' info='the result document or NULL in case of error '/>
      <arg name='style' type='xsltStylesheetPtr' info='a parsed XSLT stylesheet '/>
      <arg name='doc' type='xmlDocPtr' info='a parsed XML document '/>
      <arg name='params' type='const char **' info='a NULL terminated arry of parameters names/values tuples '/>
    </function>
    <function name='xsltApplyStylesheetUser' file='transform'>
      <info>Apply the stylesheet to the document and allow the user to provide its own transformation context.</info>
      <return type='xmlDocPtr' info='the result document or NULL in case of error '/>
      <arg name='style' type='xsltStylesheetPtr' info='a parsed XSLT stylesheet '/>
      <arg name='doc' type='xmlDocPtr' info='a parsed XML document '/>
      <arg name='params' type='const char **' info='a NULL terminated arry of parameters names/values tuples '/>
      <arg name='output' type='const char *' info='the targetted output '/>
      <arg name='profile' type='FILE *' info='profile FILE * output or NULL '/>
      <arg name='userCtxt' type='xsltTransformContextPtr' info='user provided transform context '/>
    </function>
    <function name='xsltApplyTemplates' file='transform'>
      <info>Process the apply-templates node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context '/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree. '/>
      <arg name='inst' type='xmlNodePtr' info='the apply-templates node '/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information '/>
    </function>
    <function name='xsltAttrListTemplateProcess' file='templates'>
      <info>Do a copy of an attribute list with attribute template processing</info>
      <return type='xmlAttrPtr' info='a new xmlAttrPtr, or NULL in case of error. '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context '/>
      <arg name='target' type='xmlNodePtr' info='the element where the attributes will be grafted '/>
      <arg name='cur' type='xmlAttrPtr' info='the first attribute '/>
    </function>
    <function name='xsltAttrTemplateProcess' file='templates'>
      <info>Process the given attribute and return the new processed copy.</info>
      <return type='xmlAttrPtr' info='the attribute replacement. '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context '/>
      <arg name='target' type='xmlNodePtr' info='the result node '/>
      <arg name='attr' type='xmlAttrPtr'/>
    </function>
    <function name='xsltAttrTemplateValueProcess' file='templates'>
      <info>Process the given node and return the new string value.</info>
      <return type='xmlChar *' info='the computed string value or NULL, must be deallocated by the caller. '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context '/>
      <arg name='attr' type='const xmlChar*'/>
    </function>
    <function name='xsltAttribute' file='transform'>
      <info>Process the xslt attribute node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context '/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree. '/>
      <arg name='inst' type='xmlNodePtr' info='the xslt attribute node '/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information '/>
    </function>
    <function name='xsltCalibrateAdjust' file='xsltutils'>
      <info>Used for to correct the calibration for xsltTimestamp()</info>
      <return type='void'/>
      <arg name='delta' type='long' info='a negative dealy value found '/>
    </function>
    <function name='xsltCallTemplate' file='transform'>
      <info>Process the xslt call-template node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context '/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree. '/>
      <arg name='inst' type='xmlNodePtr' info='the xslt call-template node '/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information '/>
    </function>
    <function name='xsltCheckExtPrefix' file='extensions'>
      <info>Check if the given prefix is one of the declared extensions</info>
      <return type='int' info='1 if this is an extension, 0 otherwise '/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet '/>
      <arg name='prefix' type='const xmlChar *' info='the namespace prefix (possibly NULL) '/>
    </function>
    <function name='xsltChoose' file='transform'>
      <info>Process the xslt choose node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context '/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree. '/>
      <arg name='inst' type='xmlNodePtr' info='the xslt choose node '/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information '/>
    </function>
    <function name='xsltCleanupGlobals' file='xslt'>
      <info>Unregister all global variables set up by the XSLT library</info>
      <return type='void'/>
    </function>
    <function name='xsltCleanupTemplates' file='pattern'>
      <info>Cleanup the state of the templates used by the stylesheet and the ones it imports.</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet '/>
    </function>
    <function name='xsltComment' file='transform'>
      <info>Process the xslt comment node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context '/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree. '/>
      <arg name='inst' type='xmlNodePtr' info='the xslt comment node '/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information '/>
    </function>
    <struct name='xsltCompMatch' file='pattern' info='Data structure used for the implementation of patterns. It is kept private (in pattern.c).'/>
    <typedef name='xsltCompMatchPtr' file='pattern'/>
    <function name='xsltCompilePattern' file='pattern'>
      <info>Compile the XSLT pattern and generates a list of precompiled form suitable for fast matching. </info>
      <return type='xsltCompMatchPtr' info='the generated pattern list or NULL in case of failure '/>
      <arg name='pattern' type='const xmlChar *' info='an XSLT pattern '/>
      <arg name='doc' type='xmlDocPtr' info='the containing document '/>
      <arg name='node' type='xmlNodePtr' info='the containing element '/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet '/>
      <arg name='runtime' type='xsltTransformContextPtr' info='the transformation context, if done at run-time '/>
    </function>
    <function name='xsltCopy' file='transform'>
      <info>Process the xslt copy node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context '/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree. '/>
      <arg name='inst' type='xmlNodePtr' info='the xslt copy node '/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information '/>
    </function>
    <function name='xsltCopyNamespace' file='namespaces'>
      <info>Do a copy of an namespace node. If node is non-NULL the new namespaces are added automatically. This handles namespaces aliases</info>
      <return type='xmlNsPtr' info='a new xmlNsPtr, or NULL in case of error. '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a transformation context '/>
      <arg name='node' type='xmlNodePtr' info='the target node '/>
      <arg name='cur' type='xmlNsPtr' info='the namespace node '/>
    </function>
    <function name='xsltCopyNamespaceList' file='namespaces'>
      <info>Do a copy of an namespace list. If node is non-NULL the new namespaces are added automatically. This handles namespaces aliases</info>
      <return type='xmlNsPtr' info='a new xmlNsPtr, or NULL in case of error. '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a transformation context '/>
      <arg name='node' type='xmlNodePtr' info='the target node '/>
      <arg name='cur' type='xmlNsPtr' info='the first namespace '/>
    </function>
    <function name='xsltCopyOf' file='transform'>
      <info>Process the xslt copy-of node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context '/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree. '/>
      <arg name='inst' type='xmlNodePtr' info='the xslt copy-of node '/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information '/>
    </function>
    <function name='xsltDebug' file='extra'>
      <info>Process an debug node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT processing context '/>
      <arg name='node' type='xmlNodePtr' info='The current node '/>
      <arg name='inst' type='xmlNodePtr' info='the instruction in the stylesheet '/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed informations '/>
    </function>
    <enum name='xsltDebugStatusCodes' file='xsltutils'/>
    <struct name='xsltDecimalFormat' file='xsltInternals' info='Data structure of decimal-format.'/>
    <function name='xsltDecimalFormatGetByName' file='xsltInternals'>
      <info>Find decimal-format by name</info>
      <return type='xsltDecimalFormatPtr'/>
      <arg name='sheet' type='xsltStylesheetPtr' info='the XSLT stylesheet '/>
      <arg name='name' type='xmlChar *' info='the decimal-format name to find '/>
    </function>
    <typedef name='xsltDecimalFormatPtr' file='xsltInternals'/>
    <function name='xsltDoSortFunction' file='xsltutils'>
      <info>reorder the current node list accordingly to the set of sorting requirement provided by the arry of nodes.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context '/>
      <arg name='sorts' type='xmlNodePtr *' info='array of sort nodes '/>
      <arg name='nbsorts' type='int' info='the number of sorts in the array '/>
    </function>
    <struct name='xsltDocument' file='xsltInternals' info='Data structure associated to a parsed document.'/>
    <function name='xsltDocumentComp' file='preproc'>
      <info>Pre process an XSLT-1.1 document element</info>
      <return type='xsltElemPreCompPtr'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet '/>
      <arg name='inst' type='xmlNodePtr' info='the instruction in the stylesheet '/>
      <arg name='function' type='xsltTransformFunction'/>
    </function>
    <function name='xsltDocumentElem' file='transform'>
      <info>Process an XSLT-1.1 document element</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT processing context '/>
      <arg name='node' type='xmlNodePtr' info='The current node '/>
      <arg name='inst' type='xmlNodePtr' info='the instruction in the stylesheet '/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information '/>
    </function>
    <function name='xsltDocumentFunction' file='functions'>
      <info>Implement the document() XSLT function node-set document(object, node-set?)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <typedef name='xsltDocumentPtr' file='xsltInternals'/>
    <function name='xsltDocumentSortFunction' file='xsltutils'>
      <info>reorder the current node list list accordingly to the document order</info>
      <return type='void'/>
      <arg name='list' type='xmlNodeSetPtr' info='the node set '/>
    </function>
    <functype name='xsltDropCallCallback' file='xsltutils'>
      <return type='void'/>
    </functype>
    <struct name='xsltElemPreComp' file='xsltInternals' info='The in-memory structure corresponding to element precomputed data, designed to be extended by extension implementors.'/>
    <functype name='xsltElemPreCompDeallocator' file='xsltInternals'>
      <info>Deallocates an xsltElemPreComp structure.</info>
      <return type='void'/>
      <arg name='comp' type='xsltElemPreCompPtr' info='the xsltElemPreComp to free up '/>
    </functype>
    <typedef name='xsltElemPreCompPtr' file='xsltInternals'/>
    <function name='xsltElement' file='transform'>
      <info>Process the xslt element node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context '/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree. '/>
      <arg name='inst' type='xmlNodePtr' info='the xslt element node '/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information '/>
    </function>
    <function name='xsltElementAvailableFunction' file='functions'>
      <info>Implement the element-available() XSLT function boolean element-available(string)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xsltEvalAttrValueTemplate' file='templates'>
      <info>Evaluate a attribute value template, i.e. the attribute value can contain expressions contained in curly braces ({}) and those are substituted by they computed value.</info>
      <return type='xmlChar *' info='the computed string value or NULL, must be deallocated by the caller. '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context '/>
      <arg name='node' type='xmlNodePtr' info='the stylesheet node '/>
      <arg name='name' type='const xmlChar *' info='the attribute QName '/>
      <arg name='ns' type='const xmlChar *' info='the attribute namespace URI '/>
    </function>
    <function name='xsltEvalGlobalVariables' file='variables'>
      <info>Evaluate the global variables of a stylesheet. This need to be done on parsed stylesheets before starting to apply transformations</info>
      <return type='int' info='0 in case of success, -1 in case of error '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context '/>
    </function>
    <function name='xsltEvalOneUserParam' file='variables'>
      <info>ctxt: the XSLT transformation context name: a null terminated string giving the name of the parameter value a null terminated string giving the XPath expression to be evaluated </info>
      <return type='int' info='0 in case of success, -1 in case of error. '/>
      <arg name='ctxt' type='xsltTransformContextPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='value' type='const xmlChar *'/>
    </function>
    <function name='xsltEvalStaticAttrValueTemplate' file='templates'>
      <info>Check if an attribute value template has a static value, i.e. the attribute value does not contain expressions contained in curly braces ({})</info>
      <return type='xmlChar *' info='the static string value or NULL, must be deallocated by the caller. '/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet '/>
      <arg name='node' type='xmlNodePtr' info='the stylesheet node '/>
      <arg name='name' type='const xmlChar *' info='the attribute Name '/>
      <arg name='ns' type='const xmlChar *' info='the attribute namespace URI '/>
      <arg name='found' type='int *' info='indicator whether the attribute is present '/>
    </function>
    <function name='xsltEvalTemplateString' file='templates'>
      <info>Evaluate a template string value, i.e. the parent list is interpreter as template content and the resulting tree string value is returned This is needed for example by xsl:comment and xsl:processing-instruction</info>
      <return type='xmlChar *' info='the computed string value or NULL, must be deallocated by the caller. '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context '/>
      <arg name='node' type='xmlNodePtr' info='the stylesheet node '/>
      <arg name='parent' type='xmlNodePtr' info='the content parent '/>
    </function>
    <function name='xsltEvalUserParams' file='variables'>
      <info>ctxt: the XSLT transformation context params: a NULL terminated array of parameters name/value tuples </info>
      <return type='int' info='0 in case of success, -1 in case of error '/>
      <arg name='ctxt' type='xsltTransformContextPtr'/>
      <arg name='params' type='const char **'/>
    </function>
    <function name='xsltEvalXPathPredicate' file='templates'>
      <info>Process the expression using XPath and evaluate the result as an XPath predicate</info>
      <return type='int' info='1 is the predicate was true, 0 otherwise '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context '/>
      <arg name='comp' type='xmlXPathCompExprPtr' info='the XPath compiled expression '/>
      <arg name='nsList' type='xmlNsPtr *' info='the namespaces in scope '/>
      <arg name='nsNr' type='int' info='the number of namespaces in scope '/>
    </function>
    <function name='xsltEvalXPathString' file='templates'>
      <info>Process the expression using XPath and get a string</info>
      <return type='xmlChar *' info='the computed string value or NULL, must be deallocated by the caller. '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context '/>
      <arg name='comp' type='xmlXPathCompExprPtr' info='the compiled XPath expression '/>
    </function>
    <function name='xsltExtElementLookup' file='transform'>
      <info>Looks up an extension element. ctxt can be NULL to search only in module elements.</info>
      <return type='xsltTransformFunction' info='the element callback or NULL if not found '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT process context '/>
      <arg name='name' type='const xmlChar *' info='the element name '/>
      <arg name='URI' type='const xmlChar *' info='the element namespace URI '/>
    </function>
    <function name='xsltExtFunctionLookup' file='extensions'>
      <return type='xmlXPathFunction'/>
      <arg name='ctxt' type='xsltTransformContextPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='URI' type='const xmlChar *'/>
    </function>
    <functype name='xsltExtInitFunction' file='extensions'>
      <info>A function called at initialization time of an XSLT extension module.</info>
      <return type='void *'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context '/>
      <arg name='URI' type='const xmlChar *' info='the namespace URI for the extension '/>
    </functype>
    <function name='xsltExtModuleElementLookup' file='extensions'>
      <info>Looks up an extension module element</info>
      <return type='xsltTransformFunction' info='the callback function if found, NULL otherwise. '/>
      <arg name='name' type='const xmlChar *' info='the element name '/>
      <arg name='URI' type='const xmlChar *' info='the element namespace URI '/>
    </function>
    <function name='xsltExtModuleElementPreComputeLookup' file='extensions'>
      <info>Looks up an extension module element pre-computation function</info>
      <return type='xsltPreComputeFunction' info='the callback function if found, NULL otherwise. '/>
      <arg name='name' type='const xmlChar *' info='the element name '/>
      <arg name='URI' type='const xmlChar *' info='the element namespace URI '/>
    </function>
    <function name='xsltExtModuleFunctionLookup' file='extensions'>
      <info>Looks up an extension module function</info>
      <return type='xmlXPathFunction' info='the function if found, NULL otherwise. '/>
      <arg name='name' type='const xmlChar *' info='the function name '/>
      <arg name='URI' type='const xmlChar *' info='the function namespace URI '/>
    </function>
    <function name='xsltExtModuleTopLevelLookup' file='extensions'>
      <info>Looks up an extension module top-level element</info>
      <return type='xsltTopLevelFunction' info='the callback function if found, NULL otherwise. '/>
      <arg name='name' type='const xmlChar *' info='the top-level element name '/>
      <arg name='URI' type='const xmlChar *' info='the top-level element namespace URI '/>
    </function>
    <functype name='xsltExtShutdownFunction' file='extensions'>
      <info>A function called at shutdown time of an XSLT extension module.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context '/>
      <arg name='URI' type='const xmlChar *' info='the namespace URI for the extension '/>
      <arg name='data' type='void *' info='the data associated to this module '/>
    </functype>
    <function name='xsltFindDocument' file='documents'>
      <info>Try to find a document within the XSLT transformation context</info>
      <return type='xsltDocumentPtr' info='the desired xsltDocumentPtr or NULL in case of error '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context '/>
      <arg name='doc' type='xmlDocPtr'/>
    </function>
    <function name='xsltFindElemSpaceHandling' file='imports'>
      <info>Find strip-space or preserve-space informations for an element respect the import precedence or the wildcards</info>
      <return type='int' info='1 if space should be stripped, 0 if not, and 2 if everything should be CDTATA wrapped. '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context '/>
      <arg name='node' type='xmlNodePtr' info='an XML node '/>
    </function>
    <function name='xsltFindTemplate' file='imports'>
      <info>Finds the named template, apply import precedence rule.</info>
      <return type='xsltTemplatePtr' info='the xsltTemplatePtr or NULL if not found '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context '/>
      <arg name='name' type='const xmlChar *' info='the template name '/>
      <arg name='nameURI' type='const xmlChar *' info='the template name URI '/>
    </function>
    <function name='xsltForEach' file='transform'>
      <info>Process the xslt for-each node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context '/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree. '/>
      <arg name='inst' type='xmlNodePtr' info='the xslt for-each node '/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information '/>
    </function>
    <function name='xsltFormatNumberConversion' file='xsltInternals'>
      <info>format-number() uses the JDK 1.1 DecimalFormat class: </info>
      <return type='xmlXPathError'/>
      <arg name='self' type='xsltDecimalFormatPtr' info='the decimal format '/>
      <arg name='format' type='xmlChar *' info='the format requested '/>
      <arg name='number' type='double' info='the value to format '/>
      <arg name='result' type='xmlChar **' info='the place to ouput the result '/>
    </function>
    <function name='xsltFormatNumberFunction' file='functions'>
      <info>Implement the format-number() XSLT function string format-number(number, string, string?)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xsltFreeAttributeSetsHashes' file='attributes'>
      <info>Free up the memory used by attribute sets</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet '/>
    </function>
    <function name='xsltFreeCompMatchList' file='pattern'>
      <info>Free up the memory allocated by all the elements of comp</info>
      <return type='void'/>
      <arg name='comp' type='xsltCompMatchPtr' info='an XSLT comp list '/>
    </function>
    <function name='xsltFreeCtxtExts' file='extensions'>
      <info>Free the XSLT extension data</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context '/>
    </function>
    <function name='xsltFreeDocumentKeys' file='keys'>
      <info>Free the keys associated to a document</info>
      <return type='void'/>
      <arg name='doc' type='xsltDocumentPtr' info='a XSLT document '/>
    </function>
    <function name='xsltFreeDocuments' file='documents'>
      <info>Free up all the space used by the loaded documents</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context '/>
    </function>
    <function name='xsltFreeExts' file='extensions'>
      <info>Free up the memory used by XSLT extensions in a stylesheet</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet '/>
    </function>
    <function name='xsltFreeGlobalVariables' file='variables'>
      <info>Free up the data associated to the global variables its value.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context '/>
    </function>
    <function name='xsltFreeKeys' file='keys'>
      <info>Free up the memory used by XSLT keys in a stylesheet</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet '/>
    </function>
    <function name='xsltFreeNamespaceAliasHashes' file='namespaces'>
      <info>Free up the memory used by namespaces aliases</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet '/>
    </function>
    <function name='xsltFreeStackElemList' file='xsltInternals'>
      <info>Free up the memory allocated by elem</info>
      <return type='void'/>
      <arg name='elem' type='xsltStackElemPtr' info='an XSLT stack element '/>
    </function>
    <function name='xsltFreeStyleDocuments' file='documents'>
      <info>Free up all the space used by the loaded documents</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT style sheet '/>
    </function>
    <function name='xsltFreeStylePreComps' file='preproc'>
      <info>Free up the memory allocated by all precomputed blocks</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT transformation context '/>
    </function>
    <function name='xsltFreeStylesheet' file='xsltInternals'>
      <info>Free up the memory allocated by sheet</info>
      <return type='void'/>
      <arg name='sheet' type='xsltStylesheetPtr' info='an XSLT stylesheet '/>
    </function>
    <function name='xsltFreeTemplateHashes' file='pattern'>
      <info>Free up the memory used by xsltAddTemplate/xsltGetTemplate mechanism</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet '/>
    </function>
    <function name='xsltFreeTransformContext' file='transform'>
      <info>Free up the memory allocated by ctxt</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT parser context '/>
    </function>
    <function name='xsltFunctionAvailableFunction' file='functions'>
      <info>Implement the function-available() XSLT function boolean function-available(string)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xsltFunctionNodeSet' file='extra'>
      <info>Implement the node-set() XSLT function node-set node-set(result-tree) </info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xsltGenerateIdFunction' file='functions'>
      <info>Implement the generate-id() XSLT function string generate-id(node-set?)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xsltGetExtData' file='extensions'>
      <info>Retrieve the data associated to the extension module in this given transformation.</info>
      <return type='void *'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context '/>
      <arg name='URI' type='const xmlChar *' info='the URI associated to the exension module '/>
    </function>
    <function name='xsltGetKey' file='keys'>
      <info>Lookup a key</info>
      <return type='xmlNodeSetPtr' info='the nodeset resulting from the query or NULL '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context '/>
      <arg name='name' type='const xmlChar *' info='the key name or NULL '/>
      <arg name='nameURI' type='const xmlChar *' info='the name URI or NULL '/>
      <arg name='value' type='const xmlChar *' info='the key value to look for '/>
    </function>
    <function name='xsltGetNamespace' file='namespaces'>
      <info>Find the right namespace value for this prefix, if needed create and add a new namespace decalaration on the node Handle namespace aliases</info>
      <return type='xmlNsPtr' info='the namespace node to use or NULL '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a transformation context '/>
      <arg name='cur' type='xmlNodePtr' info='the input node '/>
      <arg name='ns' type='xmlNsPtr' info='the namespace '/>
      <arg name='out' type='xmlNodePtr' info='the output node (or its parent) '/>
    </function>
    <function name='xsltGetNsProp' file='xsltutils'>
      <info>Similar to xmlGetNsProp() but with a slightly different semantic </info>
      <return type='xmlChar *' info='the attribute value or NULL if not found. It&apos;s up to the caller to free the memory. '/>
      <arg name='node' type='xmlNodePtr' info='the node '/>
      <arg name='name' type='const xmlChar *' info='the attribute name '/>
      <arg name='nameSpace' type='const xmlChar *' info='the URI of the namespace '/>
    </function>
    <function name='xsltGetQNameURI' file='xsltutils'>
      <info>This function analyzes name, if the name contains a prefix, the function seaches the associated namespace in scope for it. It will also replace name value with the NCName, the old value being freed. Errors in the prefix lookup are signalled by setting name to NULL. </info>
      <return type='const xmlChar *' info='name is not prefixed. '/>
      <arg name='node' type='xmlNodePtr' info='the node holding the QName '/>
      <arg name='name' type='xmlChar **' info='pointer to the initial QName value '/>
    </function>
    <function name='xsltGetSpecialNamespace' file='namespaces'>
      <info>Find the right namespace value for this URI, if needed create and add a new namespace decalaration on the node</info>
      <return type='xmlNsPtr' info='the namespace node to use or NULL '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a transformation context '/>
      <arg name='cur' type='xmlNodePtr' info='the input node '/>
      <arg name='URI' type='const xmlChar *' info='the namespace URI '/>
      <arg name='prefix' type='const xmlChar *' info='the suggested prefix '/>
      <arg name='out' type='xmlNodePtr' info='the output node (or its parent) '/>
    </function>
    <function name='xsltGetTemplate' file='pattern'>
      <info>Finds the template applying to this node, if style is non-NULL it means one needs to look for the next imported template in scope.</info>
      <return type='xsltTemplatePtr' info='the xsltTemplatePtr or NULL if not found '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context '/>
      <arg name='node' type='xmlNodePtr' info='the node being processed '/>
      <arg name='style' type='xsltStylesheetPtr' info='the current style '/>
    </function>
    <function name='xsltGetXIncludeDefault' file='transform'>
      <info>return the default state for XInclude processing</info>
      <return type='int' info='0 if there is no processing 1 otherwise '/>
    </function>
    <functype name='xsltHandleDebuggerCallback' file='xsltutils'>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr'/>
      <arg name='node' type='xmlNodePtr'/>
      <arg name='templ' type='xsltTemplatePtr'/>
      <arg name='ctxt' type='xsltTransformContextPtr'/>
    </functype>
    <function name='xsltIf' file='transform'>
      <info>Process the xslt if node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context '/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree. '/>
      <arg name='inst' type='xmlNodePtr' info='the xslt if node '/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information '/>
    </function>
    <function name='xsltInitCtxtExts' file='extensions'>
      <info>Initialize the set of modules with registered stylesheet data</info>
      <return type='int' info='the number of modules initialized or -1 in case of error '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context '/>
    </function>
    <function name='xsltInitCtxtKeys' file='keys'>
      <info>Computes all the keys tables for the current input document. Should be done before global varibales are initialized.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context '/>
      <arg name='doc' type='xsltDocumentPtr' info='an XSLT document '/>
    </function>
    <function name='xsltInitElemPreComp' file='extensions'>
      <info>Initializes an existing xsltElemPreComp structure. This is usefull when extending an xsltElemPreComp to store precomputed data. This function MUST be called on any extension element precomputed data struct.</info>
      <return type='void'/>
      <arg name='comp' type='xsltElemPreCompPtr' info='an xsltElemPreComp (or generally a derived structure) '/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet '/>
      <arg name='inst' type='xmlNodePtr' info='the element node '/>
      <arg name='function' type='xsltTransformFunction' info='the transform function '/>
      <arg name='freeFunc' type='xsltElemPreCompDeallocator' info='comp deallocator '/>
    </function>
    <function name='xsltIsBlank' file='xsltInternals'>
      <info>Check if a string is ignorable</info>
      <return type='int' info='1 if the string is NULL or made of blanks chars, 0 otherwise '/>
      <arg name='str' type='xmlChar *' info='a string '/>
    </function>
    <function name='xsltKeyFunction' file='functions'>
      <info>Implement the key() XSLT function node-set key(string, object)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xsltLoadDocument' file='documents'>
      <info>Try to load a document within the XSLT transformation context</info>
      <return type='xsltDocumentPtr' info='the new xsltDocumentPtr or NULL in case of error '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context '/>
      <arg name='URI' type='const xmlChar *' info='the computed URI of the document '/>
    </function>
    <function name='xsltLoadStyleDocument' file='documents'>
      <info>Try to load a document within the XSLT transformation context</info>
      <return type='xsltDocumentPtr' info='the new xsltDocumentPtr or NULL in case of error '/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT style sheet '/>
      <arg name='URI' type='const xmlChar *' info='the computed URI of the document '/>
    </function>
    <function name='xsltLoadStylesheetPI' file='xsltInternals'>
      <info>This function tries to locate the stylesheet PI in the given document If found, and if contained within the document, it will extract that subtree to build the stylesheet to process doc (doc itself will be modified). If found but referencing an external document it will attempt to load it and generate a stylesheet from it. In both cases, the resulting stylesheet and the document need to be freed once the transformation is done.</info>
      <return type='xsltStylesheetPtr' info='a new XSLT stylesheet structure or NULL if not found. '/>
      <arg name='doc' type='xmlDocPtr' info='a document to process '/>
    </function>
    <function name='xsltMatchPattern' file='pattern'>
      <info>Determine if a node matches a pattern.</info>
      <return type='int'/>
      <arg name='ctxt' type='xsltTransformContextPtr'/>
      <arg name='node' type='xmlNodePtr' info='a node in the source tree '/>
      <arg name='pattern' type='const xmlChar *' info='an XSLT pattern '/>
      <arg name='ctxtdoc' type='xmlDocPtr' info='context document (for namespaces) '/>
      <arg name='ctxtnode' type='xmlNodePtr' info='context node (for namespaces) '/>
    </function>
    <function name='xsltMessage' file='xsltutils'>
      <info>Process and xsl:message construct</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT processing context '/>
      <arg name='node' type='xmlNodePtr' info='The current node '/>
      <arg name='inst' type='xmlNodePtr' info='The node containing the message instruction '/>
    </function>
    <function name='xsltNamespaceAlias' file='namespaces'>
      <info>Read the stylesheet-prefix and result-prefix attributes, register them as well as the corresponding namespace.</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet '/>
      <arg name='node' type='xmlNodePtr' info='the xsl:namespace-alias node '/>
    </function>
    <function name='xsltNeedElemSpaceHandling' file='imports'>
      <info>Returns whether that stylesheet requires white-space stripping</info>
      <return type='int' info='1 if space should be stripped, 0 if not '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context '/>
    </function>
    <function name='xsltNewDocument' file='documents'>
      <info>Register a new document, apply key computations</info>
      <return type='xsltDocumentPtr'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context (or NULL) '/>
      <arg name='doc' type='xmlDocPtr' info='a parsed XML document '/>
    </function>
    <function name='xsltNewElemPreComp' file='extensions'>
      <info>Creates and initializes an xsltElemPreComp</info>
      <return type='xsltElemPreCompPtr' info='the new and initialized xsltElemPreComp '/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet '/>
      <arg name='inst' type='xmlNodePtr' info='the element node '/>
      <arg name='function' type='xsltTransformFunction' info='the transform function '/>
    </function>
    <function name='xsltNewStyleDocument' file='documents'>
      <info>Register a new document, apply key computations</info>
      <return type='xsltDocumentPtr'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT style sheet '/>
      <arg name='doc' type='xmlDocPtr' info='a parsed XML document '/>
    </function>
    <function name='xsltNewStylesheet' file='xsltInternals'>
      <info>Create a new XSLT Stylesheet</info>
      <return type='xsltStylesheetPtr' info='the newly allocated xsltStylesheetPtr or NULL in case of error '/>
    </function>
    <function name='xsltNewTransformContext' file='transform'>
      <info>Create a new XSLT TransformContext</info>
      <return type='xsltTransformContextPtr' info='the newly allocated xsltTransformContextPtr or NULL in case of error '/>
      <arg name='style' type='xsltStylesheetPtr' info='a parsed XSLT stylesheet '/>
      <arg name='doc' type='xmlDocPtr' info='the input document '/>
    </function>
    <function name='xsltNextImport' file='imports'>
      <info>Find the next stylesheet in import precedence.</info>
      <return type='xsltStylesheetPtr' info='the next stylesheet or NULL if it was the last one '/>
      <arg name='style' type='xsltStylesheetPtr'/>
    </function>
    <function name='xsltNumber' file='transform'>
      <info>Process the xslt number node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context '/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree. '/>
      <arg name='inst' type='xmlNodePtr' info='the xslt number node '/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information '/>
    </function>
    <function name='xsltNumberFormat' file='xsltInternals'>
      <info>Convert one number.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context '/>
      <arg name='data' type='xsltNumberDataPtr' info='the formatting informations '/>
      <arg name='node' type='xmlNodePtr' info='the data to format '/>
    </function>
    <enum name='xsltOutputType' file='xsltInternals'/>
    <function name='xsltParseGlobalParam' file='variables'>
      <info>parse an XSLT transformation param declaration and record its value.</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet '/>
      <arg name='cur' type='xmlNodePtr' info='the &quot;param&quot; element '/>
    </function>
    <function name='xsltParseGlobalVariable' file='variables'>
      <info>parse an XSLT transformation variable declaration and record its value.</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet '/>
      <arg name='cur' type='xmlNodePtr' info='the &quot;variable&quot; element '/>
    </function>
    <function name='xsltParseStylesheetAttributeSet' file='attributes'>
      <info>parse an XSLT stylesheet preserve-space element and record elements needing preserving</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet '/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xsltParseStylesheetCallerParam' file='variables'>
      <info>parse an XSLT transformation param declaration, compute its value but doesn&apos;t record it. </info>
      <return type='xsltStackElemPtr'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context '/>
      <arg name='cur' type='xmlNodePtr' info='the &quot;param&quot; element '/>
    </function>
    <function name='xsltParseStylesheetDoc' file='xsltInternals'>
      <info>parse an XSLT stylesheet building the associated structures</info>
      <return type='xsltStylesheetPtr' info='a new XSLT stylesheet structure. '/>
      <arg name='doc' type='xmlDocPtr' info='and xmlDoc parsed XML '/>
    </function>
    <function name='xsltParseStylesheetFile' file='xsltInternals'>
      <info>Load and parse an XSLT stylesheet</info>
      <return type='xsltStylesheetPtr' info='a new XSLT stylesheet structure. '/>
      <arg name='filename' type='const xmlChar*' info='the filename/URL to the stylesheet '/>
    </function>
    <function name='xsltParseStylesheetImport' file='imports'>
      <info>parse an XSLT stylesheet strip-space element and record elements needing stripping</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet '/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xsltParseStylesheetInclude' file='imports'>
      <info>parse an XSLT stylesheet strip-space element and record elements needing stripping</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet '/>
      <arg name='cur' type='xmlNodePtr'/>
    </function>
    <function name='xsltParseStylesheetOutput' file='xsltInternals'>
      <info>parse an XSLT stylesheet output element and record information related to the stylesheet output</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet '/>
      <arg name='cur' type='xmlNodePtr' info='the &quot;output&quot; element '/>
    </function>
    <function name='xsltParseStylesheetParam' file='variables'>
      <info>parse an XSLT transformation param declaration and record its value.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context '/>
      <arg name='cur' type='xmlNodePtr' info='the &quot;param&quot; element '/>
    </function>
    <function name='xsltParseStylesheetProcess' file='xsltInternals'>
      <info>parse an XSLT stylesheet adding the associated structures</info>
      <return type='xsltStylesheetPtr' info='a new XSLT stylesheet structure. '/>
      <arg name='ret' type='xsltStylesheetPtr' info='the XSLT stylesheet '/>
      <arg name='doc' type='xmlDocPtr' info='and xmlDoc parsed XML '/>
    </function>
    <function name='xsltParseStylesheetVariable' file='variables'>
      <info>parse an XSLT transformation variable declaration and record its value.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context '/>
      <arg name='cur' type='xmlNodePtr' info='the &quot;variable&quot; element '/>
    </function>
    <function name='xsltParseTemplateContent' file='xsltInternals'>
      <info>parse a template content-model Clean-up the template content from unwanted ignorable blank nodes and process xslt:text</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet '/>
      <arg name='templ' type='xmlNodePtr' info='the container node (can be a document for literal results) '/>
    </function>
    <function name='xsltPreComputeExtModuleElement' file='extensions'>
      <info>Precomputes an extension module element</info>
      <return type='xsltElemPreCompPtr' info='the precomputed data '/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet '/>
      <arg name='inst' type='xmlNodePtr' info='the element node '/>
    </function>
    <function name='xsltPrintErrorContext' file='xsltutils'>
      <info>Display the context of an error.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the transformation context '/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet '/>
      <arg name='node' type='xmlNodePtr' info='the current node being processed '/>
    </function>
    <function name='xsltProcessingInstruction' file='transform'>
      <info>Process the xslt processing-instruction node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context '/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree. '/>
      <arg name='inst' type='xmlNodePtr' info='the xslt processing-instruction node '/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information '/>
    </function>
    <function name='xsltProfileStylesheet' file='transform'>
      <info>Apply the stylesheet to the document and dump the profiling to the given output.</info>
      <return type='xmlDocPtr' info='the result document or NULL in case of error '/>
      <arg name='style' type='xsltStylesheetPtr' info='a parsed XSLT stylesheet '/>
      <arg name='doc' type='xmlDocPtr' info='a parsed XML document '/>
      <arg name='params' type='const char **' info='a NULL terminated arry of parameters names/values tuples '/>
      <arg name='output' type='FILE *' info='a FILE * for the profiling output '/>
    </function>
    <function name='xsltQuoteOneUserParam' file='variables'>
      <info>ctxt: the XSLT transformation context name: a null terminated string giving the name of the parameter value a null terminated string giving the parameter value </info>
      <return type='int' info='0 in case of success, -1 in case of error. '/>
      <arg name='ctxt' type='xsltTransformContextPtr'/>
      <arg name='name' type='const xmlChar *'/>
      <arg name='value' type='const xmlChar *'/>
    </function>
    <function name='xsltQuoteUserParams' file='variables'>
      <info>ctxt: the XSLT transformation context params: a NULL terminated arry of parameters names/values tuples </info>
      <return type='int' info='0 in case of success, -1 in case of error. '/>
      <arg name='ctxt' type='xsltTransformContextPtr'/>
      <arg name='params' type='const char **'/>
    </function>
    <function name='xsltRegisterAllElement' file='transform'>
      <info>Registers all default XSLT elements in this context</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XPath context '/>
    </function>
    <function name='xsltRegisterAllExtras' file='extra'>
      <info>Registers the built-in extensions</info>
      <return type='void'/>
    </function>
    <function name='xsltRegisterAllFunctions' file='functions'>
      <info>Registers all default XSLT functions in this context</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context '/>
    </function>
    <function name='xsltRegisterExtElement' file='extensions'>
      <info>Registers an extension element</info>
      <return type='int' info='0 in case of success, -1 in case of failure '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context '/>
      <arg name='name' type='const xmlChar *' info='the name of the element '/>
      <arg name='URI' type='const xmlChar *' info='the URI associated to the element '/>
      <arg name='function' type='xsltTransformFunction' info='the actual implementation which should be called '/>
    </function>
    <function name='xsltRegisterExtFunction' file='extensions'>
      <info>Registers an extension function</info>
      <return type='int' info='0 in case of success, -1 in case of failure '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context '/>
      <arg name='name' type='const xmlChar *' info='the name of the element '/>
      <arg name='URI' type='const xmlChar *' info='the URI associated to the element '/>
      <arg name='function' type='xmlXPathFunction' info='the actual implementation which should be called '/>
    </function>
    <function name='xsltRegisterExtModule' file='extensions'>
      <info>Register an XSLT extension module to the library.</info>
      <return type='int' info='0 if sucessful, -1 in case of error '/>
      <arg name='URI' type='const xmlChar *' info='URI associated to this module '/>
      <arg name='initFunc' type='xsltExtInitFunction' info='the module initialization function '/>
      <arg name='shutdownFunc' type='xsltExtShutdownFunction' info='the module shutdown function '/>
    </function>
    <function name='xsltRegisterExtModuleElement' file='extensions'>
      <info>Registers an extension module element.</info>
      <return type='int' info='0 if successful, -1 in case of error. '/>
      <arg name='name' type='const xmlChar *' info='the element name '/>
      <arg name='URI' type='const xmlChar *' info='the element namespace URI '/>
      <arg name='precomp' type='xsltPreComputeFunction' info='the pre-computation callback '/>
      <arg name='transform' type='xsltTransformFunction' info='the transformation callback '/>
    </function>
    <function name='xsltRegisterExtModuleFull' file='extensions'>
      <info>Register an XSLT extension module to the library.</info>
      <return type='int' info='0 if sucessful, -1 in case of error '/>
      <arg name='URI' type='const xmlChar *' info='URI associated to this module '/>
      <arg name='initFunc' type='xsltExtInitFunction' info='the module initialization function '/>
      <arg name='shutdownFunc' type='xsltExtShutdownFunction' info='the module shutdown function '/>
      <arg name='styleInitFunc' type='xsltStyleExtInitFunction' info='the module initialization function '/>
      <arg name='styleShutdownFunc' type='xsltStyleExtShutdownFunction' info='the module shutdown function '/>
    </function>
    <function name='xsltRegisterExtModuleFunction' file='extensions'>
      <info>Registers an extension module function.</info>
      <return type='int' info='0 if successful, -1 in case of error. '/>
      <arg name='name' type='const xmlChar *' info='the function name '/>
      <arg name='URI' type='const xmlChar *' info='the function namespace URI '/>
      <arg name='function' type='xmlXPathFunction' info='the function callback '/>
    </function>
    <function name='xsltRegisterExtModuleTopLevel' file='extensions'>
      <info>Registers an extension module top-level element.</info>
      <return type='int' info='0 if successful, -1 in case of error. '/>
      <arg name='name' type='const xmlChar *' info='the top-level element name '/>
      <arg name='URI' type='const xmlChar *' info='the top-level element namespace URI '/>
      <arg name='function' type='xsltTopLevelFunction' info='the top-level element callback '/>
    </function>
    <function name='xsltRegisterExtPrefix' file='extensions'>
      <info>Registers an extension namespace</info>
      <return type='int' info='0 in case of success, -1 in case of failure '/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet '/>
      <arg name='prefix' type='const xmlChar *' info='the prefix used '/>
      <arg name='URI' type='const xmlChar *' info='the URI associated to the extension '/>
    </function>
    <function name='xsltRegisterExtras' file='extra'>
      <info>Registers the built-in extensions. This function is deprecated, use xsltRegisterAllExtras instead.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context '/>
    </function>
    <function name='xsltRegisterTestModule' file='extensions'>
      <info>Registers the test module</info>
      <return type='void'/>
    </function>
    <function name='xsltRunStylesheet' file='transform'>
      <info>Apply the stylesheet to the document and generate the output according to output SAX and IObuf. It&apos;s an error to specify both SAX and IObuf. </info>
      <return type='int' info='the number of by written to the main resource or -1 in case of error. '/>
      <arg name='style' type='xsltStylesheetPtr' info='a parsed XSLT stylesheet '/>
      <arg name='doc' type='xmlDocPtr' info='a parsed XML document '/>
      <arg name='params' type='const char **' info='a NULL terminated arry of parameters names/values tuples '/>
      <arg name='output' type='const char *' info='the URL/filename ot the generated resource if available '/>
      <arg name='SAX' type='xmlSAXHandlerPtr' info='a SAX handler for progressive callback output (not implemented yet) '/>
      <arg name='IObuf' type='xmlOutputBufferPtr' info='an output buffer for progressive output (not implemented yet) '/>
    </function>
    <struct name='xsltRuntimeExtra' file='xsltInternals' info='Extra information added to the transformation context.'/>
    <typedef name='xsltRuntimeExtraPtr' file='xsltInternals'/>
    <function name='xsltSaveProfiling' file='xsltutils'>
      <info>Save the profiling informations on output</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT context '/>
      <arg name='output' type='FILE *' info='a FILE * for saving the informations '/>
    </function>
    <function name='xsltSaveResultTo' file='xsltutils'>
      <info>Save the result result obtained by applying the style stylesheet to an I/O output channel buf</info>
      <return type='int' info='the number of byte written or -1 in case of failure. '/>
      <arg name='buf' type='xmlOutputBufferPtr' info='an output buffer '/>
      <arg name='result' type='xmlDocPtr' info='the result xmlDocPtr '/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet '/>
    </function>
    <function name='xsltSaveResultToFd' file='xsltutils'>
      <info>Save the result result obtained by applying the style stylesheet to an open file descriptor This does not close the descriptor.</info>
      <return type='int' info='the number of bytes written or -1 in case of failure. '/>
      <arg name='fd' type='int' info='a file descriptor '/>
      <arg name='result' type='xmlDocPtr' info='the result xmlDocPtr '/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet '/>
    </function>
    <function name='xsltSaveResultToFile' file='xsltutils'>
      <info>Save the result result obtained by applying the style stylesheet to an open FILE * I/O. This does not close the FILE file</info>
      <return type='int' info='the number of bytes written or -1 in case of failure. '/>
      <arg name='file' type='FILE *' info='a FILE * I/O '/>
      <arg name='result' type='xmlDocPtr' info='the result xmlDocPtr '/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet '/>
    </function>
    <function name='xsltSaveResultToFilename' file='xsltutils'>
      <info>Save the result result obtained by applying the style stylesheet to a file or URL</info>
      <return type='int' info='the number of byte written or -1 in case of failure. '/>
      <arg name='URI' type='const char *'/>
      <arg name='result' type='xmlDocPtr' info='the result xmlDocPtr '/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet '/>
      <arg name='compression' type='int' info='the compression factor (0 - 9 included) '/>
    </function>
    <function name='xsltSetDebuggerCallbacks' file='xsltutils'>
      <return type='int'/>
      <arg name='no' type='int'/>
      <arg name='block' type='void *'/>
    </function>
    <function name='xsltSetGenericDebugFunc' file='xsltutils'>
      <info>Function to reset the handler and the error context for out of context error messages. This simply means that handler will be called for subsequent error messages while not parsing or validating. And ctx will be passed as first argument to handler One can simply force messages to be emitted to another FILE * than stderr by setting ctx to this file handle and handler to NULL.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the new error handling context '/>
      <arg name='handler' type='xmlGenericErrorFunc' info='the new handler function '/>
    </function>
    <function name='xsltSetGenericErrorFunc' file='xsltutils'>
      <info>Function to reset the handler and the error context for out of context error messages. This simply means that handler will be called for subsequent error messages while not parsing nor validating. And ctx will be passed as first argument to handler One can simply force messages to be emitted to another FILE * than stderr by setting ctx to this file handle and handler to NULL.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the new error handling context '/>
      <arg name='handler' type='xmlGenericErrorFunc' info='the new handler function '/>
    </function>
    <function name='xsltSetXIncludeDefault' file='transform'>
      <info>Set whether XInclude should be processed on document being loaded by default</info>
      <return type='void'/>
      <arg name='xinclude' type='int' info='whether to do XInclude processing '/>
    </function>
    <function name='xsltShutdownCtxtExts' file='extensions'>
      <info>Shutdown the set of modules loaded</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context '/>
    </function>
    <function name='xsltShutdownExts' file='extensions'>
      <info>Shutdown the set of modules loaded</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet '/>
    </function>
    <function name='xsltSort' file='transform'>
      <info>function attached to xsl:sort nodes, but this should not be called directly</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context '/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree. '/>
      <arg name='inst' type='xmlNodePtr' info='the xslt sort node '/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information '/>
    </function>
    <struct name='xsltStackElem' file='xsltInternals'/>
    <typedef name='xsltStackElemPtr' file='xsltInternals'/>
    <functype name='xsltStyleExtInitFunction' file='extensions'>
      <info>A function called at initialization time of an XSLT extension module.</info>
      <return type='void *'/>
      <arg name='style' type='xsltStylesheetPtr'/>
      <arg name='URI' type='const xmlChar *' info='the namespace URI for the extension '/>
    </functype>
    <functype name='xsltStyleExtShutdownFunction' file='extensions'>
      <info>A function called at shutdown time of an XSLT extension module.</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr'/>
      <arg name='URI' type='const xmlChar *' info='the namespace URI for the extension '/>
      <arg name='data' type='void *' info='the data associated to this module '/>
    </functype>
    <function name='xsltStyleGetExtData' file='extensions'>
      <info>Retrieve the data associated to the extension module in this given stylesheet.</info>
      <return type='void *'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet '/>
      <arg name='URI' type='const xmlChar *' info='the URI associated to the exension module '/>
    </function>
    <struct name='xsltStylePreComp' file='xsltInternals' info='The in-memory structure corresponding to XSLT stylesheet constructs precomputed data.'/>
    <typedef name='xsltStylePreCompPtr' file='xsltInternals'/>
    <function name='xsltStylePreCompute' file='preproc'>
      <info>Precompute an XSLT stylesheet element</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet '/>
      <arg name='inst' type='xmlNodePtr' info='the instruction in the stylesheet '/>
    </function>
    <enum name='xsltStyleType' file='xsltInternals'/>
    <struct name='xsltStylesheet' file='xsltInternals'/>
    <typedef name='xsltStylesheetPtr' file='xsltInternals'/>
    <function name='xsltSystemPropertyFunction' file='functions'>
      <info>Implement the system-property() XSLT function object system-property(string)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <struct name='xsltTemplate' file='xsltInternals' info='The in-memory structure corresponding to an XSLT Template.'/>
    <function name='xsltTemplateProcess' file='templates'>
      <info>Process the given node and return the new string value.</info>
      <return type='xmlNodePtr *' info='the computed tree replacement '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context '/>
      <arg name='node' type='xmlNodePtr' info='the attribute template node '/>
    </function>
    <typedef name='xsltTemplatePtr' file='xsltInternals'/>
    <function name='xsltTestCompMatchList' file='pattern'>
      <info>Test wether the node matches one of the patterns in the list</info>
      <return type='int' info='1 if it matches, 0 if it doesn&apos;t and -1 in case of failure '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context '/>
      <arg name='node' type='xmlNodePtr' info='a node '/>
      <arg name='comp' type='xsltCompMatchPtr' info='the precompiled pattern list '/>
    </function>
    <function name='xsltText' file='transform'>
      <info>Process the xslt text node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context '/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree. '/>
      <arg name='inst' type='xmlNodePtr' info='the xslt text node '/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information '/>
    </function>
    <function name='xsltTimestamp' file='xsltutils'>
      <info>Used for gathering profiling data</info>
      <return type='long' info='the number of tenth of milliseconds since the beginning of the profiling '/>
    </function>
    <functype name='xsltTopLevelFunction' file='extensions'>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr'/>
      <arg name='inst' type='xmlNodePtr'/>
    </functype>
    <struct name='xsltTransformContext' file='xsltInternals'/>
    <typedef name='xsltTransformContextPtr' file='xsltInternals'/>
    <functype name='xsltTransformFunction' file='xsltInternals'>
      <info>Signature of the function associated to elements part of the stylesheet language like xsl:if or xsl:apply-templates.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context '/>
      <arg name='node' type='xmlNodePtr' info='the input node '/>
      <arg name='inst' type='xmlNodePtr' info='the stylesheet node '/>
      <arg name='comp' type='xsltElemPreCompPtr' info='the compiled information from the stylesheet '/>
    </functype>
    <enum name='xsltTransformState' file='xsltInternals'/>
    <function name='xsltUnparsedEntityURIFunction' file='functions'>
      <info>Implement the unparsed-entity-uri() XSLT function string unparsed-entity-uri(string)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context '/>
      <arg name='nargs' type='int' info='the number of arguments '/>
    </function>
    <function name='xsltUnregisterExtModule' file='extensions'>
      <info>Unregister an XSLT extension module from the library.</info>
      <return type='int' info='0 if sucessful, -1 in case of error '/>
      <arg name='URI' type='const xmlChar *' info='URI associated to this module '/>
    </function>
    <function name='xsltUnregisterExtModuleElement' file='extensions'>
      <info>Unregisters an extension module element</info>
      <return type='int' info='0 if successful, -1 in case of error. '/>
      <arg name='name' type='const xmlChar *' info='the element name '/>
      <arg name='URI' type='const xmlChar *' info='the element namespace URI '/>
    </function>
    <function name='xsltUnregisterExtModuleFunction' file='extensions'>
      <info>Unregisters an extension module function</info>
      <return type='int' info='0 if successful, -1 in case of error. '/>
      <arg name='name' type='const xmlChar *' info='the function name '/>
      <arg name='URI' type='const xmlChar *' info='the function namespace URI '/>
    </function>
    <function name='xsltUnregisterExtModuleTopLevel' file='extensions'>
      <info>Unregisters an extension module top-level element</info>
      <return type='int' info='0 if successful, -1 in case of error. '/>
      <arg name='name' type='const xmlChar *' info='the top-level element name '/>
      <arg name='URI' type='const xmlChar *' info='the top-level element namespace URI '/>
    </function>
    <function name='xsltValueOf' file='transform'>
      <info>Process the xslt value-of node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context '/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree. '/>
      <arg name='inst' type='xmlNodePtr' info='the xslt value-of node '/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information '/>
    </function>
    <function name='xsltVariableLookup' file='variables'>
      <info>Search in the Variable array of the context for the given variable value.</info>
      <return type='xmlXPathObjectPtr' info='the value or NULL if not found '/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context '/>
      <arg name='name' type='const xmlChar *' info='the variable name '/>
      <arg name='ns_uri' type='const xmlChar *' info='the variable namespace URI '/>
    </function>
    <function name='xsltXPathFunctionLookup' file='functions'>
      <info>This is the entry point when a function is needed by the XPath interpretor.</info>
      <return type='xmlXPathFunction' info='the callback function or NULL if not found '/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='a void * but the XSLT transformation context actually '/>
      <arg name='name' type='const xmlChar *' info='the function name '/>
      <arg name='ns_uri' type='const xmlChar *' info='the function namespace URI '/>
    </function>
    <function name='xsltXPathGetTransformContext' file='extensions'>
      <info>Returns the XSLT transformation context from the XPath transformation context. This is useful when an XPath function in the extension module is called by the XPath interpreter and that the XSLT context is needed for example to retrieve the associated data pertaining to this XSLT transformation.</info>
      <return type='xsltTransformContextPtr' info='the XSLT transformation context or NULL in case of error. '/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='an XPath transformation context '/>
    </function>
    <function name='xsltXPathVariableLookup' file='variables'>
      <info>This is the entry point when a varibale is needed by the XPath interpretor.</info>
      <return type='xmlXPathObjectPtr' info='the value or NULL if not found '/>
      <arg name='ctxt' type='void *' info='a void * but the the XSLT transformation context actually '/>
      <arg name='name' type='const xmlChar *' info='the variable name '/>
      <arg name='ns_uri' type='const xmlChar *' info='the variable namespace URI '/>
    </function>
  </symbols>
</api>
